/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * home-iot-api
 * The API for the EatBacon IOT project
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://virtserver.swaggerhub.com/nycko/Test/1.0.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiResponse
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface City
 */
export interface City {
    /**
     * 
     * @type {number}
     * @memberof City
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof City
     */
    lat?: number;
    /**
     * 
     * @type {number}
     * @memberof City
     */
    lon?: number;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    country?: string;
}
/**
 * 
 * @export
 * @interface DeviceRegistrationInfo
 */
export interface DeviceRegistrationInfo {
    /**
     * 
     * @type {string}
     * @memberof DeviceRegistrationInfo
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRegistrationInfo
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface DeviceState
 */
export interface DeviceState {
    /**
     * 
     * @type {string}
     * @memberof DeviceState
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceState
     */
    name?: string;
    /**
     * 
     * @type {Date}
     * @memberof DeviceState
     */
    lastUpdate?: Date;
    /**
     * 
     * @type {number}
     * @memberof DeviceState
     */
    level?: number;
}
/**
 * 
 * @export
 * @interface Forecast
 */
export interface Forecast {
    /**
     * 
     * @type {Date}
     * @memberof Forecast
     */
    date?: Date;
    /**
     * 
     * @type {number}
     * @memberof Forecast
     */
    pressure?: number;
    /**
     * 
     * @type {number}
     * @memberof Forecast
     */
    humidity?: number;
    /**
     * 
     * @type {number}
     * @memberof Forecast
     */
    windSpeed?: number;
    /**
     * 
     * @type {number}
     * @memberof Forecast
     */
    clouds?: number;
    /**
     * 
     * @type {ForecastTemperature}
     * @memberof Forecast
     */
    temperature?: ForecastTemperature;
    /**
     * 
     * @type {WeatherForecast}
     * @memberof Forecast
     */
    weather?: WeatherForecast;
}
/**
 * 
 * @export
 * @interface ForecastResponse
 */
export interface ForecastResponse {
    /**
     * 
     * @type {City}
     * @memberof ForecastResponse
     */
    city?: City;
    /**
     * 
     * @type {Array<Forecast>}
     * @memberof ForecastResponse
     */
    values?: Array<Forecast>;
}
/**
 * 
 * @export
 * @interface ForecastTemperature
 */
export interface ForecastTemperature {
    /**
     * 
     * @type {number}
     * @memberof ForecastTemperature
     */
    low?: number;
    /**
     * 
     * @type {number}
     * @memberof ForecastTemperature
     */
    high?: number;
    /**
     * 
     * @type {number}
     * @memberof ForecastTemperature
     */
    morning?: number;
    /**
     * 
     * @type {number}
     * @memberof ForecastTemperature
     */
    day?: number;
    /**
     * 
     * @type {number}
     * @memberof ForecastTemperature
     */
    evening?: number;
    /**
     * 
     * @type {number}
     * @memberof ForecastTemperature
     */
    night?: number;
}
/**
 * 
 * @export
 * @interface HeaterState
 */
export interface HeaterState {
    /**
     * 
     * @type {string}
     * @memberof HeaterState
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof HeaterState
     */
    state?: string;
}
/**
 * ok
 * @export
 * @interface LightingSummary
 */
export interface LightingSummary {
    /**
     * 
     * @type {Array<LightingZone>}
     * @memberof LightingSummary
     */
    zones?: Array<LightingZone>;
    /**
     * 
     * @type {Array<LightingZoneStatus>}
     * @memberof LightingSummary
     */
    zoneStatus?: Array<LightingZoneStatus>;
}
/**
 * 
 * @export
 * @interface LightingZone
 */
export interface LightingZone {
    /**
     * 
     * @type {string}
     * @memberof LightingZone
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof LightingZone
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof LightingZone
     */
    deviceId?: number;
    /**
     * 
     * @type {string}
     * @memberof LightingZone
     */
    deviceType?: LightingZone.DeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof LightingZone
     */
    zone?: string;
}

/**
 * @export
 * @namespace LightingZone
 */
export namespace LightingZone {
    /**
     * @export
     * @enum {string}
     */
    export enum DeviceTypeEnum {
        Dimmer = <any> 'dimmer',
        Switch = <any> 'switch'
    }
}
/**
 * the status of the lighting zone.
 * @export
 * @interface LightingZoneStatus
 */
export interface LightingZoneStatus {
    /**
     * 
     * @type {string}
     * @memberof LightingZoneStatus
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof LightingZoneStatus
     */
    name?: string;
    /**
     * 
     * @type {Date}
     * @memberof LightingZoneStatus
     */
    lastUpdate?: Date;
    /**
     * 
     * @type {number}
     * @memberof LightingZoneStatus
     */
    level?: number;
}
/**
 * status of a single zone
 * @export
 * @interface TemperatueZoneStatus
 */
export interface TemperatueZoneStatus {
    /**
     * the unique identifier for the zone
     * @type {string}
     * @memberof TemperatueZoneStatus
     */
    id: string;
    /**
     * the name of the zone
     * @type {string}
     * @memberof TemperatueZoneStatus
     */
    name?: string;
    /**
     * the temperature in the zone
     * @type {number}
     * @memberof TemperatueZoneStatus
     */
    value: number;
    /**
     * the temperature units
     * @type {string}
     * @memberof TemperatueZoneStatus
     */
    units?: TemperatueZoneStatus.UnitsEnum;
    /**
     * the timestamp when the temperature was measured
     * @type {Date}
     * @memberof TemperatueZoneStatus
     */
    timestamp: Date;
}

/**
 * @export
 * @namespace TemperatueZoneStatus
 */
export namespace TemperatueZoneStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum UnitsEnum {
        Celsius = <any> 'celsius',
        Fahrenheit = <any> 'fahrenheit'
    }
}
/**
 * ok
 * @export
 * @interface TemperatureSummary
 */
export interface TemperatureSummary {
    /**
     * 
     * @type {Array<TemperatureZone>}
     * @memberof TemperatureSummary
     */
    zones?: Array<TemperatureZone>;
    /**
     * 
     * @type {Array<TemperatueZoneStatus>}
     * @memberof TemperatureSummary
     */
    zoneStatus?: Array<TemperatueZoneStatus>;
}
/**
 * a single temperature zone
 * @export
 * @interface TemperatureZone
 */
export interface TemperatureZone {
    /**
     * the unique identifier for the zone
     * @type {number}
     * @memberof TemperatureZone
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof TemperatureZone
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof TemperatureZone
     */
    inputPosition?: number;
    /**
     * 
     * @type {number}
     * @memberof TemperatureZone
     */
    outputPosition?: number;
    /**
     * 
     * @type {string}
     * @memberof TemperatureZone
     */
    zone?: string;
}
/**
 * 
 * @export
 * @interface WeatherForecast
 */
export interface WeatherForecast {
    /**
     * 
     * @type {string}
     * @memberof WeatherForecast
     */
    summary?: string;
    /**
     * 
     * @type {string}
     * @memberof WeatherForecast
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof WeatherForecast
     */
    icon?: string;
}
/**
 * DeviceApi - fetch parameter creator
 * @export
 */
export const DeviceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * returns all registered devices
         * @param {number} [skip] number of records to skip
         * @param {number} [limit] max number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(skip?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/devices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeviceRegistrationInfo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body?: DeviceRegistrationInfo, options: any = {}): FetchArgs {
            const localVarPath = `/devices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceRegistrationInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceApi - functional programming interface
 * @export
 */
export const DeviceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * returns all registered devices
         * @param {number} [skip] number of records to skip
         * @param {number} [limit] max number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(skip?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).getDevices(skip, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DeviceRegistrationInfo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body?: DeviceRegistrationInfo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).register(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeviceApi - factory interface
 * @export
 */
export const DeviceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * returns all registered devices
         * @param {number} [skip] number of records to skip
         * @param {number} [limit] max number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(skip?: number, limit?: number, options?: any) {
            return DeviceApiFp(configuration).getDevices(skip, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DeviceRegistrationInfo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body?: DeviceRegistrationInfo, options?: any) {
            return DeviceApiFp(configuration).register(body, options)(fetch, basePath);
        },
    };
};

/**
 * DeviceApi - object-oriented interface
 * @export
 * @class DeviceApi
 * @extends {BaseAPI}
 */
export class DeviceApi extends BaseAPI {
    /**
     * returns all registered devices
     * @param {number} [skip] number of records to skip
     * @param {number} [limit] max number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public getDevices(skip?: number, limit?: number, options?: any) {
        return DeviceApiFp(this.configuration).getDevices(skip, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DeviceRegistrationInfo} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public register(body?: DeviceRegistrationInfo, options?: any) {
        return DeviceApiFp(this.configuration).register(body, options)(this.fetch, this.basePath);
    }

}
/**
 * EnvironmentApi - fetch parameter creator
 * @export
 */
export const EnvironmentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecast(days: number, options: any = {}): FetchArgs {
            // verify required parameter 'days' is not null or undefined
            if (days === null || days === undefined) {
                throw new RequiredError('days','Required parameter days was null or undefined when calling getForecast.');
            }
            const localVarPath = `/temperature/forecast/{days}`
                .replace(`{${"days"}}`, encodeURIComponent(String(days)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * gets the state of the heater
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeaterState(zoneId: string, options: any = {}): FetchArgs {
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling getHeaterState.');
            }
            const localVarPath = `/temperature/{zoneId}/heater`
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZoneTemperature(zoneId: string, options: any = {}): FetchArgs {
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling getZoneTemperature.');
            }
            const localVarPath = `/temperature/{zoneId}`
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * turns the heater on or off
         * @param {string} zoneId 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHeaterState(zoneId: string, state: string, options: any = {}): FetchArgs {
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling setHeaterState.');
            }
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new RequiredError('state','Required parameter state was null or undefined when calling setHeaterState.');
            }
            const localVarPath = `/temperature/{zoneId}/heater/{state}`
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"state"}}`, encodeURIComponent(String(state)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        temperatureSummary(options: any = {}): FetchArgs {
            const localVarPath = `/temperature`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentApi - functional programming interface
 * @export
 */
export const EnvironmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecast(days: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ForecastResponse> {
            const localVarFetchArgs = EnvironmentApiFetchParamCreator(configuration).getForecast(days, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * gets the state of the heater
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeaterState(zoneId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HeaterState> {
            const localVarFetchArgs = EnvironmentApiFetchParamCreator(configuration).getHeaterState(zoneId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZoneTemperature(zoneId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemperatueZoneStatus> {
            const localVarFetchArgs = EnvironmentApiFetchParamCreator(configuration).getZoneTemperature(zoneId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * turns the heater on or off
         * @param {string} zoneId 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHeaterState(zoneId: string, state: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {
            const localVarFetchArgs = EnvironmentApiFetchParamCreator(configuration).setHeaterState(zoneId, state, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        temperatureSummary(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemperatureSummary> {
            const localVarFetchArgs = EnvironmentApiFetchParamCreator(configuration).temperatureSummary(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EnvironmentApi - factory interface
 * @export
 */
export const EnvironmentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecast(days: number, options?: any) {
            return EnvironmentApiFp(configuration).getForecast(days, options)(fetch, basePath);
        },
        /**
         * gets the state of the heater
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeaterState(zoneId: string, options?: any) {
            return EnvironmentApiFp(configuration).getHeaterState(zoneId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZoneTemperature(zoneId: string, options?: any) {
            return EnvironmentApiFp(configuration).getZoneTemperature(zoneId, options)(fetch, basePath);
        },
        /**
         * turns the heater on or off
         * @param {string} zoneId 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHeaterState(zoneId: string, state: string, options?: any) {
            return EnvironmentApiFp(configuration).setHeaterState(zoneId, state, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        temperatureSummary(options?: any) {
            return EnvironmentApiFp(configuration).temperatureSummary(options)(fetch, basePath);
        },
    };
};

/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
export class EnvironmentApi extends BaseAPI {
    /**
     * 
     * @param {number} days 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getForecast(days: number, options?: any) {
        return EnvironmentApiFp(this.configuration).getForecast(days, options)(this.fetch, this.basePath);
    }

    /**
     * gets the state of the heater
     * @param {string} zoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getHeaterState(zoneId: string, options?: any) {
        return EnvironmentApiFp(this.configuration).getHeaterState(zoneId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} zoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getZoneTemperature(zoneId: string, options?: any) {
        return EnvironmentApiFp(this.configuration).getZoneTemperature(zoneId, options)(this.fetch, this.basePath);
    }

    /**
     * turns the heater on or off
     * @param {string} zoneId 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public setHeaterState(zoneId: string, state: string, options?: any) {
        return EnvironmentApiFp(this.configuration).setHeaterState(zoneId, state, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public temperatureSummary(options?: any) {
        return EnvironmentApiFp(this.configuration).temperatureSummary(options)(this.fetch, this.basePath);
    }

}
/**
 * ZWaveApi - fetch parameter creator
 * @export
 */
export const ZWaveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLightingSummary(options: any = {}): FetchArgs {
            const localVarPath = `/lightingSummary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwitchState(deviceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling getSwitchState.');
            }
            const localVarPath = `/lighting/switches/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {number} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDimmer(deviceId: string, value: number, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling setDimmer.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling setDimmer.');
            }
            const localVarPath = `/lighting/dimmers/{deviceId}/{value}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * sets a dimmer to a specific value on a timer
         * @param {string} deviceId 
         * @param {number} value 
         * @param {number} timeunit 
         * @param {string} [units] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDimmerTimer(deviceId: string, value: number, timeunit: number, units?: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling setDimmerTimer.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling setDimmerTimer.');
            }
            // verify required parameter 'timeunit' is not null or undefined
            if (timeunit === null || timeunit === undefined) {
                throw new RequiredError('timeunit','Required parameter timeunit was null or undefined when calling setDimmerTimer.');
            }
            const localVarPath = `/lighting/dimmers/{deviceId}/{value}/timer/{timeunit}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)))
                .replace(`{${"timeunit"}}`, encodeURIComponent(String(timeunit)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSwitch(deviceId: string, value: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling setSwitch.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling setSwitch.');
            }
            const localVarPath = `/lighting/switches/{deviceId}/{value}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * sets a switch to a specific value on a timer
         * @param {string} deviceId 
         * @param {string} value 
         * @param {number} minutes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSwitchTimer(deviceId: string, value: string, minutes: number, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling setSwitchTimer.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling setSwitchTimer.');
            }
            // verify required parameter 'minutes' is not null or undefined
            if (minutes === null || minutes === undefined) {
                throw new RequiredError('minutes','Required parameter minutes was null or undefined when calling setSwitchTimer.');
            }
            const localVarPath = `/lighting/switches/{deviceId}/{value}/timer/{minutes}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)))
                .replace(`{${"minutes"}}`, encodeURIComponent(String(minutes)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZWaveApi - functional programming interface
 * @export
 */
export const ZWaveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLightingSummary(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightingSummary> {
            const localVarFetchArgs = ZWaveApiFetchParamCreator(configuration).getLightingSummary(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwitchState(deviceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceState> {
            const localVarFetchArgs = ZWaveApiFetchParamCreator(configuration).getSwitchState(deviceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {number} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDimmer(deviceId: string, value: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {
            const localVarFetchArgs = ZWaveApiFetchParamCreator(configuration).setDimmer(deviceId, value, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * sets a dimmer to a specific value on a timer
         * @param {string} deviceId 
         * @param {number} value 
         * @param {number} timeunit 
         * @param {string} [units] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDimmerTimer(deviceId: string, value: number, timeunit: number, units?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {
            const localVarFetchArgs = ZWaveApiFetchParamCreator(configuration).setDimmerTimer(deviceId, value, timeunit, units, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSwitch(deviceId: string, value: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {
            const localVarFetchArgs = ZWaveApiFetchParamCreator(configuration).setSwitch(deviceId, value, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * sets a switch to a specific value on a timer
         * @param {string} deviceId 
         * @param {string} value 
         * @param {number} minutes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSwitchTimer(deviceId: string, value: string, minutes: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {
            const localVarFetchArgs = ZWaveApiFetchParamCreator(configuration).setSwitchTimer(deviceId, value, minutes, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ZWaveApi - factory interface
 * @export
 */
export const ZWaveApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLightingSummary(options?: any) {
            return ZWaveApiFp(configuration).getLightingSummary(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwitchState(deviceId: string, options?: any) {
            return ZWaveApiFp(configuration).getSwitchState(deviceId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {number} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDimmer(deviceId: string, value: number, options?: any) {
            return ZWaveApiFp(configuration).setDimmer(deviceId, value, options)(fetch, basePath);
        },
        /**
         * sets a dimmer to a specific value on a timer
         * @param {string} deviceId 
         * @param {number} value 
         * @param {number} timeunit 
         * @param {string} [units] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDimmerTimer(deviceId: string, value: number, timeunit: number, units?: string, options?: any) {
            return ZWaveApiFp(configuration).setDimmerTimer(deviceId, value, timeunit, units, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSwitch(deviceId: string, value: string, options?: any) {
            return ZWaveApiFp(configuration).setSwitch(deviceId, value, options)(fetch, basePath);
        },
        /**
         * sets a switch to a specific value on a timer
         * @param {string} deviceId 
         * @param {string} value 
         * @param {number} minutes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSwitchTimer(deviceId: string, value: string, minutes: number, options?: any) {
            return ZWaveApiFp(configuration).setSwitchTimer(deviceId, value, minutes, options)(fetch, basePath);
        },
    };
};

/**
 * ZWaveApi - object-oriented interface
 * @export
 * @class ZWaveApi
 * @extends {BaseAPI}
 */
export class ZWaveApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZWaveApi
     */
    public getLightingSummary(options?: any) {
        return ZWaveApiFp(this.configuration).getLightingSummary(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} deviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZWaveApi
     */
    public getSwitchState(deviceId: string, options?: any) {
        return ZWaveApiFp(this.configuration).getSwitchState(deviceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} deviceId 
     * @param {number} value 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZWaveApi
     */
    public setDimmer(deviceId: string, value: number, options?: any) {
        return ZWaveApiFp(this.configuration).setDimmer(deviceId, value, options)(this.fetch, this.basePath);
    }

    /**
     * sets a dimmer to a specific value on a timer
     * @param {string} deviceId 
     * @param {number} value 
     * @param {number} timeunit 
     * @param {string} [units] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZWaveApi
     */
    public setDimmerTimer(deviceId: string, value: number, timeunit: number, units?: string, options?: any) {
        return ZWaveApiFp(this.configuration).setDimmerTimer(deviceId, value, timeunit, units, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} deviceId 
     * @param {string} value 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZWaveApi
     */
    public setSwitch(deviceId: string, value: string, options?: any) {
        return ZWaveApiFp(this.configuration).setSwitch(deviceId, value, options)(this.fetch, this.basePath);
    }

    /**
     * sets a switch to a specific value on a timer
     * @param {string} deviceId 
     * @param {string} value 
     * @param {number} minutes 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZWaveApi
     */
    public setSwitchTimer(deviceId: string, value: string, minutes: number, options?: any) {
        return ZWaveApiFp(this.configuration).setSwitchTimer(deviceId, value, minutes, options)(this.fetch, this.basePath);
    }

}
/**
 * ZonesApi - fetch parameter creator
 * @export
 */
export const ZonesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZones(options: any = {}): FetchArgs {
            const localVarPath = `/zones`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quietZone(zoneId: string, options: any = {}): FetchArgs {
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling quietZone.');
            }
            const localVarPath = `/zones/{zoneId}/quiet`
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZonesApi - functional programming interface
 * @export
 */
export const ZonesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZones(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ZonesApiFetchParamCreator(configuration).getZones(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quietZone(zoneId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ZonesApiFetchParamCreator(configuration).quietZone(zoneId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ZonesApi - factory interface
 * @export
 */
export const ZonesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZones(options?: any) {
            return ZonesApiFp(configuration).getZones(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quietZone(zoneId: string, options?: any) {
            return ZonesApiFp(configuration).quietZone(zoneId, options)(fetch, basePath);
        },
    };
};

/**
 * ZonesApi - object-oriented interface
 * @export
 * @class ZonesApi
 * @extends {BaseAPI}
 */
export class ZonesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonesApi
     */
    public getZones(options?: any) {
        return ZonesApiFp(this.configuration).getZones(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} zoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonesApi
     */
    public quietZone(zoneId: string, options?: any) {
        return ZonesApiFp(this.configuration).quietZone(zoneId, options)(this.fetch, this.basePath);
    }

}
